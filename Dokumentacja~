	Projekt wykorzystuje zarówno technologie połączenia klient-serwer, jak i bezpośrednie połączenie peer-to-peer. Serwer został napisny z wykorzystaniem technologii node.js, zaś aplikacja kliencka w Javie w oparciu o architekturę Mavenowską. 
	Komunikacja z serwerem wykorzystywana jest jedynie do wymiany prostych informacji, takich jak dostępne pliki, klienci udostępniający dany plik, jak również dołączania do sieci peerów. Serwer służy również do trackowania posczególnych plików i usuwaniu nieaktywnych użytkowników.
	Komunikacja z serwerem w aplikacji klienckiej polega na wydawaniu komend w trybie konsolowym. Ten sposób interakcji użytkowników wybraliśmy w celu uproszczenia interfejsu, aby miec mozliwosć skupienia się na bardziej istotnych kwestiach jak sama sieć, czy też organizowanie plików, synchronizacja.
	Możliwe komendy to: list, get file_id, put /path/to/file. Są one analogicznie tłumaczone na "język" protokołu komunikacji z serwerem, który jest opisany w osobnym pliku.
	Upload pliku wykonywany jest przez "mini serwer" działający na maszynie klienta. Nasłuchuje on na porcie 10000 i odpowiada na zapytania innych peerów wysyłając im listę posiadanych chunków czy też strumień 10 kilobajtów kawalka pilku, o który przyszlo zapytanie.
	Klient, który zdecydował się na pobranie danego pliku otrzymuje od serwera listę peerów, którzy uczestnicza w jego wymianie. Następnie aplikacja do czasu pobrania całego pliku otwiera kilka równoczesnych połączeń do różnych peerów prosząc o konkretne chunki. Są one następnie zapisywane w odpowiedniej kolejności na dysk, ostatcznie otrzymujemy cały plik. Dzięki wielu równoczesnym połączeniom można zapewnić wysoką prędkość przesyłu bez dużego obciążenia serwera (jedynie cykliczny ticki, aby powiadomić o uczestniczeniu w wymianie).

	Tworzenie sieci peer-to-peer jest wymagającym zadaniem i zdajemy sobie sprawę, że projekt można jeszcze mocno rozwinąć, jednakże z powodu ograniczeń czasowych nie było możliwe zaimplementowanie wszystkich funkcjonalności, o których pomyśleliśmy. 
	Po pierwsze uprościliśmy sposób wyboru peerów i chunków. Wykorzystaliśmy prosty algorytm losowy rezygnująć z bólem z tego opisane w analizie problemu.
	Dodatkowo serwer można jeszcze odciążyć od "ticków". W literaturze (np. w książce "Computer Networking: A Top-Down Approach") można znaleźć opis samoorganizującej i samotrackującej się sieci peerów w oparciu o rozproszone tablice hashujące.
